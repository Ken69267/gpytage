#!/usr/bin/env python
#
# GPytage v0.1_Alpha released under the GPLv2 License
# GPytage is a utility that helps manage portage's package.* files
#
############################################################################
#    Copyright (C) 2007 by Kenneth Prugh                                   #
#    ken69267@gmail.com                                                    #
#                                                                          #
#    This program is free software; you can redistribute it and#or modify  #
#    it under the terms of the GNU General Public License as published by  #
#    the Free Software Foundation under version 2 of the license.		   #
#                                                                          #
#    This program is distributed in the hope that it will be useful,       #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of        #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
#    GNU General Public License for more details.                          #
#                                                                          #
#    You should have received a copy of the GNU General Public License     #
#    along with this program; if not, write to the                         #
#    Free Software Foundation, Inc.,                                       #
#    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             #
############################################################################
import pygtk
import gtk
import os.path
import sys
import pdb

class gpytage:
	def __init__(self):
		self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		self.window.set_title("GPytage")
		self.window.set_default_size(600, 300)

		self.datastore = gtk.TreeStore(str, str, bool)
		self.files = ['package.keywords', 'package.unmask', 'package.mask', 'package.use']
		self.create_treeiter() #create the main rows

		self.treeview = gtk.TreeView(self.datastore) #create the container

		self.treeview.set_search_column(0) #search broken atm #child?
		self.treeview.set_reorderable(True) # allow inline drag and drop
		#columns
		self.namecol = gtk.TreeViewColumn('Package File')
		self.testcol = gtk.TreeViewColumn('Flags')
		self.boolcol = gtk.TreeViewColumn() #editable col
		#add to tree
		self.treeview.append_column(self.namecol)
		self.treeview.append_column(self.testcol)
		self.treeview.append_column(self.boolcol)
		#render cell
		self.cell = gtk.CellRendererText()
		self.cell1 = gtk.CellRendererText()

		#add cols to cell
		self.namecol.pack_start(self.cell, True)
		self.namecol.set_attributes(self.cell, text=0)
		self.namecol.add_attribute(self.cell, "editable", 2)#set row editable
		self.namecol.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
		self.testcol.pack_start(self.cell1, True)
		self.testcol.set_attributes(self.cell1, text=1)
		self.testcol.add_attribute(self.cell1, "editable", 2)#set row editable
		self.testcol.set_expand(True)
		self.testcol.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)

		###########Scroll Window#########################
		self.scroll = gtk.ScrolledWindow()
		self.scroll.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.scroll.add_with_viewport(self.treeview)

		###########UIManager#############################
		self.uimanager = gtk.UIManager()
		self.accelgroup = self.uimanager.get_accel_group()
		self.actiongroup = gtk.ActionGroup('GPytage')
		##UI XML
		self.ui = '''
		<ui>
			<menubar name="MenuBar">
				<menu action="File">
					<menuitem action="New" />
					<menuitem action="Save" />
					<menuitem action="Revert" />
					<menuitem action="Quit" />
				</menu>
				<menu action="Edit">
					<menuitem action="Expand All" />
					<menuitem action="Collapse All" />
					<menuitem action="Insert Package" />
					<menuitem action="Delete Package" />
				</menu>
				<menu action="Help">
					<menuitem action="About" />
				</menu>
			</menubar>
		</ui>'''
		##

		#Actions #NEEDS FIXING
		self.actiongroup.add_actions([
			('Quit', gtk.STOCK_QUIT, '_Quit', None, 'Quit GPytage', self.destroy),
			('Revert', gtk.STOCK_REVERT_TO_SAVED, '_Revert', None, 'Revert changes', self.reload),
			('New', gtk.STOCK_NEW, '_New Subfile', '<Control>n', 'New file', self.new),
			('File', None, '_File'),
			('Save', gtk.STOCK_SAVE, '_Save', '<Control>s', 'Save changes', self.save),
			('Edit', None, '_Edit'),
			('Expand All', None, '_Expand All', '<Control>backslash', 'Expand Rows', self.expand),
			('Collapse All', None, '_Collapse All', '<Control>slash', 'Collapse Rows', self.collapse),
			('Insert Package', None, '_Insert Package', '<Control>t', 'Add a package', self.insertrow),
			('Delete Package', None, '_Delete Package', 'Delete', "Delete a package", self.deleterow),
			('Help',None,'_Help'),
			('About', gtk.STOCK_ABOUT, '_About', None, 'About GPytage', self.about)])

		#Add the UI XML
		self.uimanager.insert_action_group(self.actiongroup, 0)
		self.uimanager.add_ui_from_string(self.ui)

		#Menubar
		self.menubar = self.uimanager.get_widget('/MenuBar')
		self.vbox = gtk.VBox() #the master widgit
		self.vbox.pack_start(self.menubar, False)
		
		################Connections##################
		#allow the program to quit
		self.window.connect("destroy", self.destroy)
		self.window.connect("delete_event", self.delete_event)
		self.cell.connect("edited", self.edited_cb, self.datastore, 0)
		self.cell1.connect("edited", self.edited_cb, self.datastore, 1)
		self.treeview.connect("button_press_event", self.clicked)
		#############################################

		###########Show Widgits##########################
		self.vbox.pack_start(self.scroll, True, True, 0)
		#self.vbox.pack_start(self.treeview, True)
		self.window.add_accel_group(self.accelgroup)
		#self.window.add_accel_group(self.accelgroup)
		#self.window.add(self.scroll)
		self.window.add(self.vbox)
#		#self.window.add(self.treeview)
		self.window.show_all()

	############Signal Functions###########################
	def destroy(self, widget, data=None):
		gtk.main_quit()

	def delete_event(self, widget, event, data=None):
		return False

	def edited_cb(self, cell, path, new_text, user_data, col):
		self.datastore[path][col] = new_text
		self.window.set_title("* GPytage")
		return

	def clicked(self, view, event):
		if event.button == 3:
			menu = gtk.Menu()
			irow = gtk.MenuItem("Insert Package")
			irow.connect("activate", self.insertrow)
			drow= gtk.MenuItem("Delete Package")
			drow.connect("activate", self.deleterow)
			menu.append(irow)
			menu.append(drow)
			menu.show_all()
			menu.popup(None, None, None, event.button, event.time)

	############Menu Functions. ###########################
	def about(self, arg): #wth is arg
		aboutw = gtk.AboutDialog()
		aboutw.set_name('GPytage')
		aboutw.set_copyright('Copyright 2007, GPL2')
		aboutw.set_authors(['Kenneth Prugh', '\nWith special thanks to the Gentoo \ndevelopers and community', '\nLicensed under the GPL-2'])
		f=open('/usr/portage/licenses/GPL-2')
		gpl2 = f.read()
		f.close
		aboutw.set_license(gpl2)
		aboutw.set_wrap_license(True)
		aboutw.set_version('0.1_Alpha')
		aboutw.set_website('https://gna.org/projects/gpytage/')
		aboutw.run()
		aboutw.hide()
	
	def reload(self, arg): #reloads all rows in treeview
		self.datastore.clear()
		self.create_treeiter()
		self.window.set_title("GPytage")

	def save(self, arg): #the important one...
		for row in self.datastore: #iters through parents
			file = 'package.'+row[0] #eg: package.keywords
			simlist = [] #uh, write this to file i guess
			for child in row.iterchildren(): #child of parents
				if child[2] == False: #if its false it has subfiles
					subdlist = []
					for cell in child.iterchildren(): #child.iter is subfile
						datarow = self.assemblerow(cell)
						subdlist.append(datarow)
					self.savefile(file, child[0], subdlist)
				else:
					#print child #list
					datarow = self.assemblerow(child)
					simlist.append(datarow)
			if simlist != []:
				self.savefile(file, None, simlist)
		self.window.set_title("GPytage")
	#insight: datastore can be thought of a giant list, where row[0] references the first item in a multi list list. eg: foo = [['blah'],['blah1']]

	def new(self, arg):#create a new subfile
		newd = gtk.Dialog('Create new Subfile', self.window, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, None)
		dirs,files = self.folder_scan()
		#eventually you will be able to create a new subfile from a files
		#selection rather than just dirs
		cb = gtk.combo_box_new_text()
		for i in dirs:
			cb.append_text(i)
		cb.set_active(0)
		sbox = gtk.HBox()
		sbox.pack_start(gtk.Label("Parent directory:"))
		sbox.pack_start(cb)
		newd.vbox.pack_start(sbox)
		ftextbox = gtk.HBox()
		flabel = gtk.Label("New subfile name:")
		ftext = gtk.Entry()
		ftextbox.pack_start(flabel)
		ftextbox.pack_start(ftext)
		newd.vbox.pack_start(ftextbox)
		addb = gtk.Button("Add", gtk.STOCK_ADD)
		closeb = gtk.Button("Close",gtk.STOCK_CLOSE)
		addb.connect("clicked", self.add_subfile, cb, ftext, newd)
		closeb.connect("clicked", self.close_subfile, newd)
		newd.action_area.pack_start(closeb)
		newd.action_area.pack_start(addb)
		newd.show_all()
		newd.run()

	def close_subfile(self, arg, newd):
		newd.hide()

	def add_subfile(self, arg, cb, ftext, newd):
		model = cb.get_model()
		index = cb.get_active()
		ftextselection = ftext.get_text()
		Success = False
		if len(ftextselection):
			Success = True
			self.create_subfile(cbselection, ftextselection)
		if Success:
			arg = "subfile" #no idea...reload needs something passed
			self.reload(arg)
			newd.hide() #destroy better?

	def create_subfile(self, cbselection, ftextselection):
		try:
			path = "/etc/portage/%s/%s" %(cbselection, ftextselection)
			print path
			msg= '''# This file was created by GPytage.'''
			f=open(path, 'w')
			f.write(msg)
			f.close
		except IOError:
			print 'Failed to open /etc/portage/%s/%s' %(cbselection,ftext)

	def expand(self, arg):
		self.treeview.expand_all()

	def collapse(self, arg):
		self.treeview.collapse_all()

	def selected(self): #helper function
		selection = self.treeview.get_selection()
		model, iter = selection.get_selected()
		try:
			value = self.datastore.get_value(iter, 2)
		except:
			value = False
		return iter, value


	def insertrow(self, arg):
		iter, value = self.selected()
		if value == True:
			niter = self.datastore.insert_after(None, iter, [None, None, True])
			path = self.datastore.get_path(niter)
			self.treeview.set_cursor_on_cell(path, self.namecol, self.cell, True)
			self.window.set_title("* GPytage")

	def deleterow(self, arg):
		iter, value = self.selected()
		if value == True:
			self.datastore.remove(iter)
			self.window.set_title("* GPytage")
			
	#######################################################

	def folder_scan(self):#returns what files are files/dirs wrt portage
		dirs = []
		file = []
		for i in self.files:
			result = os.path.isdir("/etc/portage/"+i)
			if(result):
				dirs.append(i)
			else:
				file.append(i)
		return dirs, file

	def folder_walk(self,dir):#returns list of files within dirs
		dir_files = []
		for i in os.listdir('/etc/portage/'+dir+'/'):
			dir_files.append(i)
		return dir_files

	
	def create_treeiter(self):#create the parent/main rows
		parent_folder, simple_files = self.folder_scan()
		#parent_files = self.folder_walk(parent_folder)
		for i in simple_files: #needs no sub main rows just data
			name = i.partition('.')[2]
			siter = name+"_iter"
			siter = self.datastore.append(None, [name, None, False])
			data = self.scan_contents(i)
			for row in data:
				col1 = row[0].rstrip() #strips \n
				try:
					col2 = row[1].rstrip() # not all files have 2 cols
				except:
					col2 = None
				self.datastore.append(siter, [col1, col2, True])
		for i in parent_folder: #parent_folders is list of folders such as package.keywords
			#i is a dir such as package.keywords
			pfolder = i
			name = i.partition('.')[2]
			giter = name+"_iter"
			giter = self.datastore.append(None, [name, None, False])
			complex_files = self.folder_walk(i) #this needs to return list files in dir
			for i in complex_files: #"simple files"
				name = i #folder name being iterated
				gciter = name+"_iter"
				gciter = self.datastore.append(giter, [name, None, False])
				dir_file_path = pfolder+'/'+i
				data = self.scan_contents(dir_file_path)
				for row in data:
					col1 = row[0].rstrip()
					try:
						col2 = row[1].rstrip()
					except:
						col2 = None
					self.datastore.append(gciter, [col1,col2, True])

					
	def scan_contents(self,arg):#returns data in specified file
		try:
			f=open("/etc/portage/"+arg, 'r')
			contents = f.readlines()
			f.close()
		except IOError: #needed or everything breaks
			print 'Warning: Critical file /etc/%s not found, creating...' % arg
			writemessage = '''# This file was created by GPytage as it is required for proper operation.'''
			f=open("/etc/portage/"+arg, 'w')
			f.write(writemessage)
			f.close

		data = [] #list of list: eg [['python','x86']]
		for i in contents:
			if i.startswith('#'): #don't split if its a comment
				new = [i, None]
			else:
				new = i.split(None,1)
			data.append(new)
		return data #return the master list of lists

	def assemblerow(self, child):
		try:
			len(child[0])
			text1 = child[0]
		except:
			text1 = ""
		try:
			len(child[1])
			text2 = child[1]
		except:
			text2 = ""
		datarow = text1 + " " + text2 + '\n'
		return datarow

	def savefile(self, package, subfile, rowlist):
		if subfile is None:
			try:
				f=open('/etc/portage/'+package, 'w')
			except IOError:
				print 'Failed to open /etc/portage/' + package + ' for write access'
				#sys.exit()
			for row in rowlist:
				f.write(row)
			f.close
		else:
			try:
				f=open('/etc/portage/'+package+'/'+subfile, 'w')
			except IOError:
				print 'failed to open /etc/portage/'+package+'/'+subfile + ' for write access'
			for row in rowlist:
				f.write(row)
			f.close

	def main(self):
		gtk.main()

if __name__ == "__main__":
	gpytage = gpytage()
	gpytage.main()
